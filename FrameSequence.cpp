#include "FrameSequence.h"

namespace MSPCAM001{
	MSPCAM001::FrameSequence::FrameSequence(): frameSizeX(0) , frameSizeY(0), imageSizeX(0), imageSizeY(0)
	{}
	/* destructor loops through every frame in the image sequence
	and frees up all the memory used by the dynamically allocated
	2d array */
	MSPCAM001::FrameSequence::~FrameSequence() 
	{
		if(!((this->imageSequence).empty()))
		{
			for(unsigned char ** frame : this->imageSequence)
			{
				for(int i=0;i<this->frameSizeY;i++)
				{
					delete [] frame[i];
				}
				delete [] frame;
			}
			imageSequence.clear();
		}
	}
	/* Set the size of the full image and the size of the frames the 
	program must create */
	void MSPCAM001::FrameSequence::setSize(int framex, int framey, int imagex, int imagey)  
	{
		this->frameSizeX=framex;
		this->frameSizeY=framey;
		this->imageSizeX=imagex; 
		this->imageSizeY=imagey;
	}
	void MSPCAM001::FrameSequence::read(unsigned char *pixels, int originx, int originy)
	{
		unsigned char ** frame = new unsigned char * [this->frameSizeY]; //allocate how many rows and columns the frame must have
		for (int i=0; i<this->frameSizeX; i++){
			frame[i] = new unsigned char[this->frameSizeX];
		}
		for (int j=originy;j<originy+this->frameSizeY;j++)
		{
			for (int k=originx;k<originx+this->frameSizeX;k++)
			{
				if (k>=(this->imageSizeX) || j>=(this->imageSizeY)){
					/*This is true when the pixel we are
					trying to copy is off the original
					image */
					int outofbounds = 255;
					frame[j-originy][k-originx] = static_cast<unsigned char>(outofbounds);
					continue;
				}
				/* find the pixel in the
				1D array which matches the
				2D coordinate system */			
				frame[j-originy][k-originx] = pixels[((this->imageSizeX)*j)+k];
			}
		}
		(this->imageSequence).push_back(frame);
	}
	void MSPCAM001::FrameSequence::gradientCalculator(int xcoord, int ycoord, int xend, int yend, unsigned char * pixels)
	{
		float gradient = (float)(yend-ycoord)/float(xend-xcoord);
		read(pixels,xcoord,ycoord);
		if (fabs(gradient)<=1.0)
		{
			/* The change in y is greater than the change in x
			and therefore we will have instances where we have 
			to increment the y value by 1 and not the x */
			if(xcoord <xend){ // increments x in positive direction
				for(int i=xcoord+1;i<=xend; i++)
				{
					if (ycoord < yend)
					{
						ycoord+=fabs(gradient);
					}
					else{
						ycoord-=fabs(gradient);
					}
					read(pixels,i,std::round(ycoord));
				}
			}
			else{
				for(int j=xcoord-1;j>=xend; j--)
				{
					if (ycoord < yend)
					{
						ycoord+=fabs(gradient);
					}
					else{
						ycoord-=fabs(gradient);
					}
					read(pixels,j,std::round(ycoord));
				}
			}
		}
		else{
			gradient = (float)(xend-xcoord)/(float)(yend-ycoord); // set gradient to 1/g as change in x is now greater
			if(ycoord <yend){
				for(int k=ycoord+1;k<=yend; k++)
				{
					if (xcoord < xend)
					{
						xcoord+=fabs(gradient);
					}
					else{
						xcoord-=fabs(gradient);
					}
					read(pixels,std::round(xcoord),k);
				}
			}
			else{
				for(int l=ycoord-1;l>=yend; l--)
				{
					if (xcoord < xend)
					{
						xcoord+=fabs(gradient);
					}
					else{
						xcoord-=fabs(gradient);
					}
					read(pixels,std::round(xcoord),l);
				}
			}
		}
	}
	void MSPCAM001::FrameSequence::write(std::string filename, std::string option)
	{
		// Writes out the pgm files to the current directory
		std::string comment = "#This image was generated by MSPCAM001::FrameSequence";
		std::ofstream outfile;
		if(option.compare("none")==0 || option.compare("invert")==0)
		{
			bool inversion=false;
			if (option.compare("invert")==0){ //Tells us if every pixel we iterate through must be inverted
				inversion=true;
			}
			for(int i=0;i<(this->imageSequence).size();i++)
			{
				std::string fullname,versionnumber;
				std::stringstream version;
				version.fill('0');
				version.width(4); // Similar to %04d
				version << std::to_string(i); // allows for incrementing filename
				version >> versionnumber;
				fullname = filename+"-"+versionnumber+".pgm";
				outfile.open(fullname, std::ios::binary);
				std::string brightness = "255";
				std::string size = std::to_string(this->frameSizeX) + " " + std::to_string(this->frameSizeY);
				outfile << "P5" << std::endl << comment << std::endl << size << std::endl << brightness <<std::endl;
				for(int j=0; j<(this->frameSizeY);j++)
				{
					for (int k=0;k<(this->frameSizeX);k++)
					{
						if (inversion){ 
							// Uses a new unsigned char to store the inverted values, this allows us to not alter the original extracted data
							unsigned char * initial = &((this->imageSequence)[i][j][k]);
							unsigned char v = 255;
	        					unsigned char finalvalue = static_cast<unsigned char>(v - *initial);
	        					outfile.write(reinterpret_cast<const char *>(&finalvalue), 1);
	        				}
	        				else{
						outfile.write(reinterpret_cast<const char *>(&((this->imageSequence)[i][j][k])), 1);
						}
						//write one pixel to the output file at a time
					}
				}
				outfile.close();
			}
		}
		if(option.compare("reverse")==0 || option.compare("revinvert")==0)
		{
			bool inversion=false;
			if (option.compare("revinvert")==0){
				inversion=true;
			}
			for(int i=(this->imageSequence).size()-1;i>=0;i--)
			{
				//initial loop is the only change which iterates through the extracted frames in reverse order
				std::string fullname,versionnumber;
				std::stringstream version;
				version.fill('0');
				version.width(4);
				version << std::to_string((this->imageSequence.size())-i-1);
				version >> versionnumber;
				fullname = filename+"-"+versionnumber+".pgm";
				outfile.open(fullname, std::ios::binary);
				std::string brightness = "255";
				std::string size = std::to_string(this->frameSizeX) + " " + std::to_string(this->frameSizeY);
				outfile << "P5" << std::endl << comment << std::endl << size << std::endl << brightness <<std::endl;
				for(int j=0; j<(this->frameSizeY);j++)
				{
					for (int k=0;k<(this->frameSizeX);k++)
					{
						if (inversion){
							unsigned char * initial = &((this->imageSequence)[i][j][k]);
							unsigned char v = 255;
	        					unsigned char finalvalue = static_cast<unsigned char>(v - *initial);
	        					outfile.write(reinterpret_cast<const char *>(&finalvalue), 1);
	        				}
	        				else{
						outfile.write(reinterpret_cast<const char *>(&((this->imageSequence)[i][j][k])), 1);
						}
					}
				}
				outfile.close();
			}
		}
	}
}	
			
