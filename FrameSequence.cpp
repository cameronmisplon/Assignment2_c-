#include "FrameSequence.h"

namespace MSPCAM001{
	MSPCAM001::FrameSequence::FrameSequence(): frameSizeX(0) , frameSizeY(0), imageSizeX(0), imageSizeY(0)
	{}
	MSPCAM001::FrameSequence::~FrameSequence()
	{
		if(!((this->imageSequence).empty()))
		{
			for(unsigned char ** frame : this->imageSequence)
			{
				for(int i=0;i<this->frameSizeY;i++)
				{
					delete [] frame[i];
				}
				delete [] frame;
			}
			imageSequence.clear();
		}
	}
	void MSPCAM001::FrameSequence::setSize(int framex, int framey, int imagex, int imagey)  
	{
		this->frameSizeX=framex;
		this->frameSizeY=framey;
		this->imageSizeX=imagex; 
		this->imageSizeY=imagey;
	}
	void MSPCAM001::FrameSequence::read(unsigned char *pixels, int originx, int originy)
	{
		unsigned char ** frame = new unsigned char * [this->frameSizeY];
		for (int i=0; i<this->frameSizeX; i++){
			frame[i] = new unsigned char[this->frameSizeX];
		}
		for (int j=originy;j<originy+this->frameSizeY;j++)
		{
			for (int k=originx;k<originx+this->frameSizeX;k++)
			{
				frame[j-originy][k-originx] = pixels[((this->imageSizeX)*j)+k];
			}
		}
		(this->imageSequence).push_back(frame);
	}
	void MSPCAM001::FrameSequence::gradientCalculator(int xcoord, int ycoord, int xend, int yend, unsigned char * pixels)
	{
		float gradient = (float)(yend-ycoord)/float(xend-xcoord);
		read(pixels,xcoord,ycoord);
		if (fabs(gradient)<=1.0)
		{
			if(xcoord <xend){
				for(int i=xcoord+1;i<=xend; i++)
				{
					if (ycoord < yend)
					{
						ycoord+=fabs(gradient);
					}
					else{
						ycoord-=fabs(gradient);
					}
					read(pixels,i,std::round(ycoord));
				}
			}
			else{
				for(int j=xcoord-1;j>=xend; j--)
				{
					if (ycoord < yend)
					{
						ycoord+=fabs(gradient);
					}
					else{
						ycoord-=fabs(gradient);
					}
					read(pixels,j,std::round(ycoord));
				}
			}
		}
		else{
			gradient = (float)(xend-xcoord)/(float)(yend-ycoord);
			if(ycoord <yend){
				for(int k=ycoord+1;k<=yend; k++)
				{
					if (xcoord < xend)
					{
						xcoord+=fabs(gradient);
					}
					else{
						xcoord-=fabs(gradient);
					}
					read(pixels,std::round(xcoord),k);
				}
			}
			else{
				for(int l=ycoord-1;l>=yend; l--)
				{
					if (xcoord < xend)
					{
						xcoord+=fabs(gradient);
					}
					else{
						xcoord-=fabs(gradient);
					}
					read(pixels,std::round(xcoord),l);
				}
			}
		}
	}
	void MSPCAM001::FrameSequence::write(std::string filename, std::string option)
	{
		std::string comment = "#This image was generated by MSPCAM001::FrameSequence";
		std::ofstream outfile;
		if(option.compare("none")==0 || option.compare("invert")==0)
		{
			bool inversion=false;
			if (option.compare("invert")==0){
				inversion=true;
			}
			for(int i=0;i<(this->imageSequence).size();i++)
			{
				std::string fullname,versionnumber;
				std::stringstream version;
				version.fill('0');
				version.width(4);
				version << std::to_string(i);
				version >> versionnumber;
				fullname = filename+"-"+versionnumber+".pgm";
				outfile.open(fullname, std::ios::binary);
				std::string brightness = "255";
				std::string size = std::to_string(this->frameSizeX) + " " + std::to_string(this->frameSizeY);
				outfile << "P5" << std::endl << comment << std::endl << size << std::endl << brightness <<std::endl;
				for(int j=0; j<(this->frameSizeY);j++)
				{
					for (int k=0;k<(this->frameSizeX);k++)
					{
						if (inversion){
							unsigned char * initial = &((this->imageSequence)[i][j][k]);
							unsigned char v = 255;
	        					unsigned char finalvalue = static_cast<unsigned char>(v - *initial);
	        					outfile.write(reinterpret_cast<const char *>(&finalvalue), 1);
	        				}
	        				else{
						outfile.write(reinterpret_cast<const char *>(&((this->imageSequence)[i][j][k])), 1);
						}
					}
				}
				outfile.close();
			}
		}
		if(option.compare("reverse")==0 || option.compare("revinvert")==0)
		{
			bool inversion=false;
			if (option.compare("revinvert")==0){
				inversion=true;
			}
			for(int i=(this->imageSequence).size()-1;i>=0;i--)
			{
				std::string fullname,versionnumber;
				std::stringstream version;
				version.fill('0');
				version.width(4);
				version << std::to_string((this->imageSequence.size())-i-1);
				version >> versionnumber;
				fullname = filename+"-"+versionnumber+".pgm";
				outfile.open(fullname, std::ios::binary);
				std::string brightness = "255";
				std::string size = std::to_string(this->frameSizeX) + " " + std::to_string(this->frameSizeY);
				outfile << "P5" << std::endl << comment << std::endl << size << std::endl << brightness <<std::endl;
				for(int j=0; j<(this->frameSizeY);j++)
				{
					for (int k=0;k<(this->frameSizeX);k++)
					{
						if (inversion){
							unsigned char * initial = &((this->imageSequence)[i][j][k]);
							unsigned char v = 255;
	        					unsigned char finalvalue = static_cast<unsigned char>(v - *initial);
	        					outfile.write(reinterpret_cast<const char *>(&finalvalue), 1);
	        				}
	        				else{
						outfile.write(reinterpret_cast<const char *>(&((this->imageSequence)[i][j][k])), 1);
						}
					}
				}
				outfile.close();
			}
		}
	}
}	
			
